# 商品收藏功能技术架构设计

## 1. 功能概述

商品收藏功能允许客户用户收藏自己喜欢的商品，以便稍后查看或购买。该功能包括：
- 商品详情页添加/取消收藏按钮
- 个人中心的收藏商品列表
- 收藏商品的快速访问和管理

## 2. 技术架构设计

### 2.1 后端架构

#### 2.1.1 数据模型设计

**1. 创建收藏实体类 (`ProductFavorite.java`)**

```java
package com.shop.model;

import javax.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "product_favorites", uniqueConstraints = {
    @UniqueConstraint(columnNames = {"customer_id", "product_id"}) // 确保一个用户只能收藏同一商品一次
})
public class ProductFavorite {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "customer_id", nullable = false)
    private Customer customer;
    
    @ManyToOne
    @JoinColumn(name = "product_id", nullable = false)
    private Product product;
    
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    // Getters and Setters
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
    }
}
```

**2. 扩展Customer实体类**

```java
// 在Customer.java中添加
@OneToMany(mappedBy = "customer", cascade = CascadeType.ALL, orphanRemoval = true)
private List<ProductFavorite> favoriteProducts;
```

#### 2.1.2 数据访问层

**创建收藏仓库接口 (`ProductFavoriteRepository.java`)**

```java
package com.shop.repository;

import com.shop.model.ProductFavorite;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface ProductFavoriteRepository extends JpaRepository<ProductFavorite, Long> {
    // 检查用户是否已收藏某商品
    boolean existsByCustomerIdAndProductId(Long customerId, Long productId);
    
    // 获取用户的所有收藏商品
    List<ProductFavorite> findByCustomerIdOrderByCreatedAtDesc(Long customerId);
    
    // 根据用户ID和商品ID查找收藏记录
    Optional<ProductFavorite> findByCustomerIdAndProductId(Long customerId, Long productId);
    
    // 删除用户的收藏商品
    void deleteByCustomerIdAndProductId(Long customerId, Long productId);
}
```

#### 2.1.3 服务层

**创建收藏服务接口和实现**

```java
// ProductFavoriteService.java
package com.shop.service;

import com.shop.model.ProductFavorite;
import java.util.List;

public interface ProductFavoriteService {
    // 添加商品到收藏
    ProductFavorite addToFavorites(Long customerId, Long productId);
    
    // 从收藏中移除商品
    void removeFromFavorites(Long customerId, Long productId);
    
    // 检查商品是否已被收藏
    boolean isProductFavorited(Long customerId, Long productId);
    
    // 获取用户的所有收藏商品
    List<ProductFavorite> getCustomerFavorites(Long customerId);
}

// ProductFavoriteServiceImpl.java
package com.shop.service.impl;

import com.shop.model.ProductFavorite;
import com.shop.repository.ProductFavoriteRepository;
import com.shop.repository.CustomerRepository;
import com.shop.repository.ProductRepository;
import com.shop.service.ProductFavoriteService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

@Service
public class ProductFavoriteServiceImpl implements ProductFavoriteService {
    
    @Autowired
    private ProductFavoriteRepository favoriteRepository;
    
    @Autowired
    private CustomerRepository customerRepository;
    
    @Autowired
    private ProductRepository productRepository;
    
    @Override
    @Transactional
    public ProductFavorite addToFavorites(Long customerId, Long productId) {
        // 检查用户和商品是否存在
        var customer = customerRepository.findById(customerId)
            .orElseThrow(() -> new RuntimeException("Customer not found"));
        
        var product = productRepository.findById(productId)
            .orElseThrow(() -> new RuntimeException("Product not found"));
        
        // 检查是否已收藏
        if (favoriteRepository.existsByCustomerIdAndProductId(customerId, productId)) {
            throw new RuntimeException("Product already favorited");
        }
        
        // 创建收藏记录
        var favorite = new ProductFavorite();
        favorite.setCustomer(customer);
        favorite.setProduct(product);
        
        return favoriteRepository.save(favorite);
    }
    
    @Override
    @Transactional
    public void removeFromFavorites(Long customerId, Long productId) {
        favoriteRepository.deleteByCustomerIdAndProductId(customerId, productId);
    }
    
    @Override
    public boolean isProductFavorited(Long customerId, Long productId) {
        return favoriteRepository.existsByCustomerIdAndProductId(customerId, productId);
    }
    
    @Override
    public List<ProductFavorite> getCustomerFavorites(Long customerId) {
        return favoriteRepository.findByCustomerIdOrderByCreatedAtDesc(customerId);
    }
}
```

#### 2.1.4 控制器层

**创建收藏控制器 (`ProductFavoriteController.java`)**

```java
package com.shop.controller;

import com.shop.model.ProductFavorite;
import com.shop.service.ProductFavoriteService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/customer/favorites")
public class ProductFavoriteController {
    
    @Autowired
    private ProductFavoriteService favoriteService;
    
    // 添加收藏
    @PostMapping("/add/{productId}")
    public ResponseEntity<ProductFavorite> addToFavorites(
            @PathVariable Long productId,
            @RequestParam Long customerId) {
        // 实际项目中应从JWT令牌获取customerId
        var favorite = favoriteService.addToFavorites(customerId, productId);
        return ResponseEntity.ok(favorite);
    }
    
    // 取消收藏
    @DeleteMapping("/remove/{productId}")
    public ResponseEntity<?> removeFromFavorites(
            @PathVariable Long productId,
            @RequestParam Long customerId) {
        favoriteService.removeFromFavorites(customerId, productId);
        return ResponseEntity.ok(Map.of("message", "Product removed from favorites"));
    }
    
    // 检查是否已收藏
    @GetMapping("/check/{productId}")
    public ResponseEntity<Map<String, Boolean>> checkFavorite(
            @PathVariable Long productId,
            @RequestParam Long customerId) {
        boolean isFavorited = favoriteService.isProductFavorited(customerId, productId);
        return ResponseEntity.ok(Map.of("isFavorited", isFavorited));
    }
    
    // 获取用户收藏列表
    @GetMapping("/list")
    public ResponseEntity<List<ProductFavorite>> getFavorites(@RequestParam Long customerId) {
        List<ProductFavorite> favorites = favoriteService.getCustomerFavorites(customerId);
        return ResponseEntity.ok(favorites);
    }
}
```

### 2.2 前端架构

#### 2.2.1 组件设计

**1. 商品详情页收藏按钮 (`ProductDetail.vue`)**

```vue
<template>
  <div class="product-detail">
    <!-- 商品信息显示 -->
    <!-- ... -->
    
    <!-- 收藏按钮 -->
    <button 
      class="favorite-btn" 
      :class="{ 'favorited': isFavorited }"
      @click="toggleFavorite"
    >
      <i :class="isFavorited ? 'fas fa-heart' : 'far fa-heart'">
      {{ isFavorited ? '已收藏' : '收藏' }}
    </button>
    
    <!-- 其他功能按钮 -->
    <!-- ... -->
  </div>
</template>

<script>
export default {
  data() {
    return {
      productId: null,
      customerId: null, // 实际项目中应从登录状态获取
      isFavorited: false,
      loading: false
    }
  },
  mounted() {
    this.productId = this.$route.params.id;
    this.customerId = this.$store.state.user.id; // 从Vuex存储获取用户ID
    this.checkFavoriteStatus();
  },
  methods: {
    async checkFavoriteStatus() {
      this.loading = true;
      try {
        const response = await this.$axios.get(`/api/customer/favorites/check/${this.productId}`, {
          params: { customerId: this.customerId }
        });
        this.isFavorited = response.data.isFavorited;
      } catch (error) {
        console.error('Check favorite status failed:', error);
      } finally {
        this.loading = false;
      }
    },
    
    async toggleFavorite() {
      this.loading = true;
      try {
        if (this.isFavorited) {
          // 取消收藏
          await this.$axios.delete(`/api/customer/favorites/remove/${this.productId}`, {
            params: { customerId: this.customerId }
          });
          this.isFavorited = false;
          this.$message.success('已取消收藏');
        } else {
          // 添加收藏
          await this.$axios.post(`/api/customer/favorites/add/${this.productId}`, null, {
            params: { customerId: this.customerId }
          });
          this.isFavorited = true;
          this.$message.success('已添加到收藏');
        }
      } catch (error) {
        console.error('Toggle favorite failed:', error);
        this.$message.error('操作失败，请重试');
      } finally {
        this.loading = false;
      }
    }
  }
}
</script>

<style scoped>
.favorite-btn {
  padding: 10px 20px;
  border: 1px solid #ff4d4f;
  background-color: white;
  color: #ff4d4f;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
  transition: all 0.3s;
}

.favorite-btn.favorited {
  background-color: #ff4d4f;
  color: white;
}

.favorite-btn:hover {
  opacity: 0.8;
}
</style>
```

**2. 收藏商品列表组件 (`FavoriteProducts.vue`)**

```vue
<template>
  <div class="favorite-products">
    <h2>我的收藏</h2>
    
    <div v-if="loading" class="loading">加载中...</div>
    
    <div v-else-if="favorites.length === 0" class="empty">
      <i class="far fa-heart"></i>
      <p>您还没有收藏任何商品</p>
    </div>
    
    <div v-else class="product-list">
      <div v-for="favorite in favorites" :key="favorite.id" class="product-card">
        <router-link :to="`/product/${favorite.product.id}`" class="product-link">
          <img :src="favorite.product.imageUrl" :alt="favorite.product.name" class="product-image">
          <div class="product-info">
            <h3 class="product-name">{{ favorite.product.name }}</h3>
            <p class="product-price">¥{{ favorite.product.price.toFixed(2) }}</p>
            <p class="product-desc">{{ favorite.product.description.substring(0, 100) }}...</p>
            <span class="favorite-date">收藏于: {{ formatDate(favorite.createdAt) }}</span>
          </div>
        </router-link>
        
        <button class="remove-btn" @click="removeFavorite(favorite)">
          <i class="fas fa-trash"></i> 取消收藏
        </button>
      </div>
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      customerId: null,
      favorites: [],
      loading: false
    }
  },
  mounted() {
    this.customerId = this.$store.state.user.id; // 从Vuex存储获取用户ID
    this.loadFavorites();
  },
  methods: {
    async loadFavorites() {
      this.loading = true;
      try {
        const response = await this.$axios.get('/api/customer/favorites/list', {
          params: { customerId: this.customerId }
        });
        this.favorites = response.data;
      } catch (error) {
        console.error('Load favorites failed:', error);
        this.$message.error('加载收藏列表失败');
      } finally {
        this.loading = false;
      }
    },
    
    async removeFavorite(favorite) {
      try {
        await this.$axios.delete(`/api/customer/favorites/remove/${favorite.product.id}`, {
          params: { customerId: this.customerId }
        });
        // 从列表中移除
        this.favorites = this.favorites.filter(fav => fav.id !== favorite.id);
        this.$message.success('已取消收藏');
      } catch (error) {
        console.error('Remove favorite failed:', error);
        this.$message.error('操作失败，请重试');
      }
    },
    
    formatDate(dateString) {
      const date = new Date(dateString);
      return date.toLocaleString('zh-CN');
    }
  }
}
</script>

<style scoped>
.favorite-products {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

.product-list {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 20px;
  margin-top: 20px;
}

.product-card {
  border: 1px solid #e8e8e8;
  border-radius: 8px;
  padding: 15px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  transition: box-shadow 0.3s;
}

.product-card:hover {
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
}

.product-link {
  text-decoration: none;
  color: #333;
}

.product-image {
  width: 100%;
  height: 200px;
  object-fit: cover;
  border-radius: 4px;
  margin-bottom: 10px;
}

.product-name {
  font-size: 18px;
  margin-bottom: 8px;
}

.product-price {
  font-size: 20px;
  color: #ff4d4f;
  font-weight: bold;
  margin-bottom: 8px;
}

.product-desc {
  color: #666;
  margin-bottom: 10px;
  line-height: 1.5;
}

.favorite-date {
  font-size: 12px;
  color: #999;
}

.remove-btn {
  margin-top: 10px;
  padding: 8px 16px;
  background-color: #ff4d4f;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.3s;
}

.remove-btn:hover {
  background-color: #ff7875;
}

.loading, .empty {
  text-align: center;
  padding: 50px 0;
  color: #666;
}

.empty i {
  font-size: 48px;
  margin-bottom: 10px;
  color: #ccc;
}
</style>
```

#### 2.2.2 路由配置

在Vue Router中添加收藏列表路由：

```javascript
// router/index.js
const routes = [
  // 其他路由
  {
    path: '/favorites',
    name: 'Favorites',
    component: () => import('../views/FavoriteProducts.vue'),
    meta: { requiresAuth: true } // 需要登录才能访问
  }
]
```

## 3. 技术学习建议

为了更好地实现和优化商品收藏功能，建议学习以下新技术：

### 3.1 后端技术

**1. Spring Security + JWT**
- 学习如何使用JWT进行用户身份验证
- 实现基于角色的访问控制
- 从JWT令牌中提取用户信息，而不是通过URL参数传递

**2. Redis缓存**
- 使用Redis缓存热门收藏商品
- 缓存用户的收藏列表，提高读取性能
- 实现收藏数量的实时统计

**3. Spring Data Redis**
- 学习Spring Data Redis的使用
- 实现Redis与Spring Boot的集成
- 设计高效的Redis缓存策略

### 3.2 前端技术

**1. Vuex状态管理**
- 学习如何使用Vuex管理全局状态
- 实现用户登录状态的管理
- 统一处理API请求和响应

**2. Vue Router高级功能**
- 实现路由守卫，控制页面访问权限
- 学习嵌套路由和动态路由的使用
- 实现路由懒加载，提高应用性能

**3. Axios拦截器**
- 实现请求拦截器，统一添加认证信息
- 实现响应拦截器，统一处理错误和异常
- 实现请求重试和超时处理

**4. 响应式设计**
- 学习响应式设计原则
- 实现移动端友好的收藏功能界面
- 优化不同设备上的用户体验

### 3.3 性能优化技术

**1. 前端性能优化**
- 实现图片懒加载
- 使用虚拟滚动处理大量收藏商品
- 优化组件渲染性能

**2. 后端性能优化**
- 实现数据库索引优化
- 学习查询优化技巧
- 实现异步处理和并行查询

**3. 系统架构优化**
- 学习微服务架构设计
- 实现服务间通信和调用
- 设计可扩展的系统架构

## 4. 实现步骤

1. 创建收藏实体类和数据库表
2. 实现后端服务和API接口
3. 配置Spring Security和JWT认证
4. 实现前端收藏按钮和列表组件
5. 集成Redis缓存提高性能
6. 进行功能测试和性能优化

## 5. 总结

商品收藏功能是电商平台的重要功能之一，通过合理的技术架构设计和新技术的应用，可以为用户提供良好的使用体验。在实现过程中，需要注意数据一致性、性能优化和用户体验等方面的问题，确保功能的稳定和高效运行。